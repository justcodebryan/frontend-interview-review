# 事件委托

定义: 利用事件冒泡, 只指定一个事件处理程序, 就可以管理某一类型的所有事件

事件冒泡机制: 事件从最深的节点开始, 然后逐步向上传播事件

作用:

- 减少与 DOM 交互的次数, 提升性能
- 添加的事件处理程序是函数, 函数是对象, 对象需要占用内存空间, 减少内存空间的占用

浏览器事件处理机制, 每个浏览器的处理方式不一样

事件处理机制的 `DOM2.0` 的标准:

1. 事件捕获阶段: 当某个元素触发某个事件时, 顶层对象 document 就会发出一个事件流, 随着 DOM 树的节点向着目标元素流去, 在这个过程中, 事件相应的监听函数是不会被触发的
2. 事件目标阶段: 当到达目标元素之后, 执行目标元素该事件相应的处理函数, 如果没有绑定监听函数则不执行
3. 事件冒泡阶段: 从目标元素开始, 向顶层元素传播, 如果有节点绑定了相应的事件处理函数, 这些函数都会被触发一次

适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。值得注意的是，mouseover 和 mouseout 虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。

不适合: mousemove，每次都要计算它的位置，非常不好把控，再比如说 focus，blur，load，unload 之类的，本身就没用冒泡的特性，自然就不能用事件委托了。

`React`的事件系统就利用了事件冒泡的特性

事件绑定阶段:

1. `React`执行`diff`操作, 标记出那些`DOM`类型的节点需要添加或者更新
2. 当检测到需要创建一个节点或者更新一个节点的时候, 使用`registerationNameModule`查看一个`props`是不是事件类型, 如果是则执行下一步
3. 通过`registrationNameDependencies`检查这个`React`事件依赖了哪些原生事件类型
4. 检查这些原生事件类型有没有注册过, 如果有则忽略
5. 如果这个原生事件类型没有注册过, 则注册这个原生事件到`document`上, 回调为`React`提供的`dispatchEvent`函数

说明:

1. 所有事件类型都注册到`document`上

# `e.target`与`e.currentTarget`的区别

`target`: 一个触发事件对象的引用, 当事件处理程序在事件的冒泡或者捕获阶段被调用
`currentTarget`: 当事件遍历`DOM`时, 标识事件的当前目标, 他总是引用时间处理程序附加到的元素, 而不是`event.target`, 他标识事件发生的元素
