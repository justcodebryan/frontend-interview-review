# 好处

1. 缓解服务器压力
2. 提升性能
3. 减少带宽消耗, 只会产生很小的网络消耗

# 种类

1. 数据库缓存

   将查询到的数据放到内存中进行缓存, 下次再查询时, 就直接从内存缓存中获取, 从而提高响应速度

2. `CDN`缓存

   `CDN`会计算去哪得到这些内容的路径最短而且最快

3. 代理服务器缓存

   代理服务器缓存性质和浏览器缓存一样, 代理服务器缓存面向的用户更多, 规模更大, 为多个用户服务

4. 浏览器缓存

   实现了`HTTP`缓存, 通过浏览器使用`HTTP`协议与服务器交互的时候, 浏览器就会根据一套与服务器约定的规则进行缓存工作, 当我们在浏览器中点击前进和后退按钮时, 利用的就是浏览器的缓存机制

# 缓存过程

- 强缓存
- 协商缓存

# 缓存位置

- `Service Worker`
- `Memory Cache`
- `Disk Cache`
- `Push Cache`

# 强缓存

当访问`URL`的时候, 不会向服务器发送请求, 直接从缓存中的读取资源, 但是会返回 200 的状态码

如何设置?

第一进入页面, 请求服务器, 然后服务器进行应答, 浏览器会根据`Response Header`来判断是否对资源进行缓存

如果响应头中有`expires` , `pragma`或者`cache-control`字段, 代表是强缓存

浏览器就会将资源缓存到`Memory Cache`或者`Disk Cache`中

第二次请求的时候, 浏览器判断请求参数

- 如果符合强缓存条件就直接返回状态码 200, 从本地缓存中拿数据(`Expires`和`Cache-Control`)(`Cache-control`优先级高于`Expires`)
- 响应参数存在`Request Header`里, 看是否符合协商缓存, 符合则返回状态码 304(`Etag/If-None-Match`优先级高于`Last-Modified/If-Modified-Since`)
- 不符合 -> 返回全新资源

## expires

是`HTTP1.0`控制网页缓存的字段, 值为一个时间戳

服务器返回该结果缓存到期的时间 -> 对比 expires 的时间戳:

- 如果未超过过期时间, 直接使用该缓存
- 如果过期了则重新缓存

缺点: 用本地时间判断, 本地时间可以修改

## Cache-Control

`HTTP1.1`中控制网页缓存的字段, 优先级高于`Expires`

- `public`: 资源客户端和服务器都可以缓存
- `private`: 资源只有客户端可以缓存
- `no-cache`: 客户端缓存资源, 但是是否缓存需要经过协商缓存来验证
- `no-store`: 不用缓存
- `max-age`: 缓存保质期

`max-age`使用相对时间, 解决了`expires`的问题

## pragma

`HTTP1.0`中禁用网页缓存的字段, 取值为`no-cache`

# 缓存位置

图像和网页等资源主要缓存在`Disk cache`

操作系统缓存文件等资源大部分放在`Memory Cache`

查找缓存的时候会按照顺序查找:

`Service Worker` -> `Memory Cache` -> `Disk Cache` -> `Push Cache`

1. `Service Worker`
   - 运行在浏览器后面的独立线程
   - 传输协议必须为`HTTPS`
   - 可以由开发者自由控制缓存存入哪些文件, 如何匹配缓存, 如何读取缓存, 并且缓存是持续性的
2. `Memory Cache`
   - 页面中已经抓取的资源: 已经下载的样式, 脚本, 图片等
   - 随着进程的释放而释放
3. `Disk Cache`
   - 覆盖面最大
   - 根据`HTTP Header`中字段判断哪些资源需要缓存, 哪些资源可以不请求直接使用, 哪些资源已经过期需要重新请求
   - `prefetch cache`(预取缓存) -> 预加载的一种方式, 会在浏览器空闲时间加载
4. `Push Cache`
   - `HTTP/2`中的内容
   - 会话结束后被释放
   - 缓存时间短, 5 分钟后过期

# 协商缓存

强缓存失效后, 浏览器携带缓存标识向服务器发送请求, 由服务器根据缓存标识来决定是否使用缓存的过程

两种情况:

- 协商缓存生效
- 返回 304

如何设置协商缓存
`Last-Modified/If-Modified-Since`

`Last-Modified`是服务器响应请求时, 返回改资源文件在服务器最后被修改的时间

`If-Modified-Since`则是客户端再次发起该请求时，携带上次请求返回的`Last-Modified`值，

- 通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有`If-Modified-Since`字段，则会根据`If-Modified-Since`的字段值与该资源在服务器的最后被修改时间做对比，
  - 若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200；
  - 否则则返回 304，代表资源无更新，可继续使用缓存文件。

`ETag/If-None-Match`

`ETag`是服务器响应请求时, 返回当前资源文件的一个唯一标识(由服务器生成)

`If-None-Match`是客户端再次发送该请求时, 携带上次请求返回的唯一标识`ETag`值, 通过此字段值告诉服务器该资源上次请求返回的唯一标识值

- 如果发现该请求头中含有`If-None-Match`, 比较该资源在服务器的`Etag`,
  - 一致返回 304, 代表资源无更新, 继续使用缓存文件
  - 不一致重新返回资源文件, 状态码为 200

# 缓存方案

`HTML`: 协商缓存

`css`, `js`, 图片: 强缓存, 文件名带上`hash`

# 强缓存与协商缓存的区别

1. 强缓存不发送请求到服务器, 所以有时候资源更新了服务器也不知道
2. 协商缓存会发送请求到服务器, 所以资源是否更新, 服务器肯定知道

大部分 web 服务器默认开启协商缓存

# 刷新对于强缓存和协商缓存的影响

1. `Ctrl + F5`: 强制刷新网页, 直接从服务器加载, 跳过强缓存和协商缓存
2. `F5`: 跳过强缓存, 但是会检查协商缓存
3. 写入`URL`: 如果发现缓存中有这个文件了, 直接从缓存中取
