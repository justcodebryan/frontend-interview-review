1. webpack 优化 loader 与 plugin 分别是干什么的有什么区别

- loader，它是一个转换器，将 A 文件进行编译成 B 文件，比如：将 A.less 转换为 A.css，单纯的文件转换过程。

- plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务

2. ES6 特性

- let const var

- 解构赋值

- Array

  - 扩展运算符
  - `Array.from()` -> 将类数组对象和可遍历对象转换成数组
  - `Array.of()` -> 将一组数转换成数组
  - `copyWithin()`
    将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组

    参数如下：

    target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
    start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
    end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。

    ```js
    ;[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2// [4, 5, 3, 4, 5]
    ```

  - `find()`、`findIndex()`
  - `fill()`
  - `entries()`，`keys()`，`values()`
  - `includes()`
  - `flat()`，`flatMap()`

- Map Set

- WeakMap WeakSet

  WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合

  在 API 中 WeakMap 与 Map 有两个区别：

  没有遍历操作的 API
  没有 clear 清空方法
  WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名
  WeakMap 的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用

  注意：WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用

  下面代码中，键值 obj 会在 WeakMap 产生新的引用，当你修改 obj 不会影响到内部

  ```js
  const wm = new WeakMap()
  let key = {}
  let obj = { foo: 1 }
  wm.set(key, obj)
  obj = null
  wm.get(key)
  // Object {foo: 1}
  ```

3. var let 的区别

- 变量提升
- 是否会污染全局对象
- TDZ 暂时性死区
- 块级作用域
- 重复声明

4. 箭头函数

**箭头函数表达式**的语法比[函数表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function)更简洁，并且没有自己的[`this`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)，[`arguments`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments)，[`super`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super)或[`new.target`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target)。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。

作用：更简短的函数 并且 不绑定`this`

没有单独的`this`

在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值：

- 如果该函数是一个构造函数，this 指针指向一个新的对象
- 在严格模式下的函数调用下，this 指向`undefined`
- 如果该函数是一个对象的方法，则它的 this 指针指向这个对象

```js
function Person() {
  // Person() 构造函数定义 `this`作为它自己的实例。
  this.age = 0

  setInterval(function growUp() {
    // 在非严格模式，growUp() 函数定义 `this`作为全局对象，
    // 与在 Person() 构造函数中定义的 `this`并不相同。
    this.age++
  }, 1000)
}

var p = new Person()
```

箭头函数不会创建自己的`this，它只会从自己的作用域链的上一层继承 this`。因此，在下面的代码中，传递给`setInterval`的函数内的`this`与封闭函数中的`this`值相同：

```js
function Person() {
  this.age = 0

  setInterval(() => {
    this.age++ // |this| 正确地指向 p 实例
  }, 1000)
}

var p = new Person()
```

通过 call 或 apply 调用
由于 箭头函数没有自己的 this 指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定 this---译者注），他们的第一个参数会被忽略。（这种现象对于 bind 方法同样成立 --- 译者注）

```js
var adder = {
  base: 1,
  add: function (a) {
    var f = (v) => v + this.base
    return f(a)
  },
  addThruCall: function (a) {
    var f = (v) => v + this.base
    var b = { base: 2 }
    return f.call(b, a)
  },
}

console.log(adder.add(1)) // 输出 2
console.log(adder.addThruCall(1)) // 仍然输出 2
```

不绑定 arguments, 只是引用封闭作用域里面的 arguments

不能用作构造器, 和 `new` 一起使用会抛出错误

箭头函数没有 `prototype` 属性

5. this 指向的几种情况

- 作为对象的方法调用
  当函数作为对象的方法被调用时，this 指向该对象

```js
let obj = {
  a: 1,
  getA: function () {
    alert(this === obj) // 输出: true
    alert(this.a) // 输出: 1
  },
}

obj.getA()
```

- 作为普通函数调用
  此时的 this 总是指向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象

```js
window.name = 'globalName'

let getName = function () {
  return this.name
}

console.log(getName()) // output: globalName

let myObject = {
  name: 'seven',
  getName: function () {
    return this.name
  },
}

var getName = myObject.getName
console.log(getName()) // output: globalName
```

- 构造器调用
  通常情况下，构造器里的 this 就指向返回的这个对象

```js
let MyClass = function () {
  this.name = 'shintaro'
}
let obj = new MyClass()
console.log(obj.name) // output:'shintaro'
```

如上 obj 复制了 MyClass 的原型也获得了其中的 name 属性，但当构造器函数显示的返回了一个 object 类型的对象时，那么使用 new 调用构造器后获得的 this 环境就是这个对象

```js
let MyClass = function () {
  this.name = 'shintaro'
  return {
    name: 'Faker',
  }
}
let obj = new MyClass()
console.log(obj.name) //output:'Faker'
```

- Function.prototype.call / Function.prototype.apply
  call/apply/bind call/apply/bind 函数接受一个参数从而能够动态的改变传入函数运行时的 this:

  ```js
  var obj1 = {
    name: 'sven',
    getName: function () {
      return this.name
    },
  }

  var obj2 = {
    name: 'anne',
  }
  console.log(obj1.getName()) // output:sven
  console.log(obj1.getName.call(obj2)) // output:anne
  ```

  - call 和 apply 都能接受第二个或是更多的参数作为运行指定函数时，所使用的参数并运行
  - bind 函数同上，但是不会立即运行而是返回一个设置好 this 指针以及参数的函数

6. call, apply, bind 的区别

apply 接受两个参数，第一个参数是 this 的指向，第二个参数是函数接受的参数，以数组的形式传入，且当第一个参数为 null、undefined 的时候，默认指向 window(在浏览器中)，使用 apply 方法改变 this 指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。
日常用法：改变 this 指向

call 方法的第一个参数也是 this 的指向，后面传入的是一个参数列表（注意和 apply 传参的区别）。当一个参数为 null 或 undefined 的时候，表示指向 window（在浏览器中），和 apply 一样，call 也只是临时改变一次 this 指向，并立即执行。

bind 方法
bind 方法和 call 很相似，第一参数也是 this 的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入，call 则必须一次性传入所有参数)，但是它改变 this 指向后不会立即执行，而是返回一个永久改变 this 指向的函数。

总结:

- 三者都可以改变函数的 this 对象指向。
- 三者第一个参数都是 this 要指向的对象，如果如果没有这个参数或参数为 undefined 或 null，则默认指向全局 window。
- 三者都可以传参，但是 apply 是数组，而 call 是参数列表，且 apply 和 call 是一次性传入参数，而 bind 可以分为多次传入。
- bind 是返回绑定 this 之后的函数，便于稍后调用；apply 、call 则是立即执行 。

7. 原型 原型链

8. 闭包 闭包的应用

9. web 安全（问了怎么防止爬虫）

- XSS 攻击： 跨站脚本攻击。

攻击者脚本 嵌入 被攻击网站，获取用户 cookie 等隐私信息。

- CSRF 攻击： 跨站请求伪造。

已登录用户 访问 攻击者网站，攻击网站向被攻击网站发起恶意请求（利用浏览器会自动携带 cookie）。

- 如何防止爬虫

  - 经常修改 HTML 的结构
  - 蜜罐和假数据
  - 使用混淆的 JavaScript、Ajax 还有 Cookie
  - 频率限制、爬虫检测和请求封禁

10. 输入 url 到页面加载过程 这个过程中 DNS 解析具体过程可以说一下吗

11. 事件冒泡 事件捕获

12. async defer 的区别

13. 性能优化

14. 事件循环

15. 什么是强缓存 什么是协商缓存 怎么判断

浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力

http 缓存机制主要在 http 响应头中设定，响应头中相关字段为 Expires、Cache-Control、Last-Modified、Etag。

HTTP 1.0 协议中的。简而言之，就是告诉浏览器在约定的这个时间前，可以直接从缓存中获取资源（representations），而无需跑到服务器去获取

Expires 因为是对时间设定的，且时间是 Greenwich Mean Time （GMT），而不是本地时间，所以对时间要求较高。

强缓存：浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回 Status Code: 200 OK
Expires：过期时间，如果设置了时间，则浏览器会在设置的时间内直接读取缓存，不再请求
Cache-Control：当值设为 max-age=300 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的 5 分钟内再次加载资源，就会命中强缓存。
cache-control：除了该字段外，还有下面几个比较常用的设置值：
（1） max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；
（2） s-maxage：和 max-age 是一样的，不过它只针对代理服务器缓存而言；
（3）public：指示响应可被任何缓存区缓存；
（4）private：只能针对个人用户，而不能被代理服务器缓存；
（5）no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到 请求，然后判断资源是否变更，是则返回新内容，否则返回 304，未变更。这个很容易让人产生误解，使人误 以为是响应不被缓存。实际上 Cache-Control: no-cache 是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。
（6）no-store：禁止一切缓存（这个才是响应不被缓存的意思）。

cache-control 是 http1.1 的头字段，expires 是 http1.0 的头字段,如果 expires 和 cache-control 同时存在，cache-control 会覆盖 expires，建议两个都写。

协商缓存: 向服务器发送请求，服务器会根据这个请求的 request header 的一些参数来判断是否命中协商缓存，如果命中，则返回 304 状态码并带上新的 response header 通知浏览器从缓存中读取资源；

Last-Modified/If-Modified-Since 和 Etag/If-None-Match 是分别成对出现的，呈一一对应关系

Etag/If-None-Match：

Etag：

Etag 是属于 HTTP 1.1 属性，它是由服务器（Apache 或者其他工具）生成返回给前端，用来帮助服务器控制 Web 端的缓存验证。
Apache 中，ETag 的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行 Hash 后得到的。

If-None-Match:

当资源过期时，浏览器发现响应头里有 Etag,则再次像服务器请求时带上请求头 if-none-match(值是 Etag 的值)。服务器收到请求进行比对，决定返回 200 或 304

Last-Modified/If-Modified-Since：

Last-Modified：

浏览器向服务器发送资源最后的修改时间

If-Modified-Since：

当资源过期时（浏览器判断 Cache-Control 标识的 max-age 过期），发现响应头具有 Last-Modified 声明，则再次向服务器请求时带上头 if-modified-since，表示请求时间。服务器收到请求后发现有 if-modified-since 则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。

注意:

- Last-Modified/If-Modified-Since 的时间精度是秒，而 Etag 可以更精确。
- Etag 优先级是高于 Last-Modified 的，所以服务器会优先验证 Etag
- Last-Modified/If-Modified-Since 是 http1.0 的头字段

16. HTTP 状态码

17. 简单请求与复杂请求

满足以下条件的请求即为简单请求:

- 请求方法: GET/POST/HEAD
- 除以下的请求头字段以外, 没有自定义的请求头:

  - Accept
  - Accept-Language
  - Content-Language
  - Content-Type
  - DPR
  - Downlink
  - Save-Data
  - Viewport-Width
  - Width

- Content-Type 的值只有以下三种(Content-Type 一般是指在 post 请求中，get 请求中设置没有实际意义)

  - text/plain
  - multipart/form-data
  - application/x-www-form-urlencoded

- 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器 (未验证)

  - XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问

- 请求中没有使用 ReadableStream 对象 (未验证)

简单请求的发送从代码上来看和普通的 XHR 没太大区别，但是 HTTP 头当中要求总是包含一个域（Origin）的信息。该域包含协议名、地址以及一个可选的端口，不过这一项实际上由浏览器代为发送

复杂请求

非简单请求即为复杂请求。复杂请求我们也可以称之为在实际进行请求之前，需要发起预检请求的请求。

复杂请求表面上看起来和简单请求使用上差不多，但实际上浏览器发送了不止一个请求。其中最先发送的是一种"预请求"，此时作为服务端，也需要返回"预回应"作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。

预请求以 OPTIONS 形式发送，当中同样包含域，并且还包含了两项 CORS 特有的内容：

- Access-Control-Request-Method – 该项内容是实际请求的种类，可以是 GET、POST 之类的简单请求，也可以是 PUT、DELETE 等等。
- Access-Control-Request-Headers – 该项是一个以逗号分隔的列表，当中是复杂请求所使用的头部。

18. 怎么实现跨域

- jsonp

  ```js
  // index.html
  function jsonp({ url, params, callback }) {
    return new Promise((resolve, reject) => {
      let script = document.createElement('script')
      window[callback] = function (data) {
        resolve(data)
        document.body.removeChild(script)
      }
      params = { ...params, callback } // wd=b&callback=show
      let arrs = []
      for (let key in params) {
        arrs.push(`${key}=${params[key]}`)
      }
      script.src = `${url}?${arrs.join('&')}`
      document.body.appendChild(script)
    })
  }
  jsonp({
    url: 'http://localhost:3000/say',
    params: { wd: 'Iloveyou' },
    callback: 'show',
  }).then((data) => {
    console.log(data)
  })
  ```

- cors

  服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

- postMessage

  postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：

  - 页面和其打开的新窗口的数据传递
  - 多窗口之间消息传递
  - 页面与嵌套的 iframe 消息传递
  - 上面三个场景的跨域数据传递

  postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。

- Node 中间件代理(两次跨域)

  实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 代理服务器，需要做以下几个步骤：

  - 接受客户端请求 。
  - 将请求 转发给服务器。
  - 拿到服务器 响应 数据。
  - 将 响应 转发给客户端。

- nginx 反向代理

  实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。
  使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。
  实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。

- window.name + iframe

  window.name 属性的独特之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。
  其中 a.html 和 b.html 是同域的，都是 http://localhost:3000;而 c.html 是 http://localhost:4000

- location.hash + iframe

  实现原理： a.html 欲与 c.html 跨域相互通信，通过中间页 b.html 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。
  具体实现步骤：一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。
  同样的，a.html 和 b.html 是同域的，都是 http://localhost:3000;而 c.html 是 http://localhost:4000

- document.domain + iframe

  该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。
  只需要给页面添加 document.domain ='test.com' 表示二级域名都相同就可以实现跨域。
  实现原理：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。

19. 了解过函数式编程吗

20. 怎么判断是数组还是对象

- constructor
- instanceof
- Array.isArray()
- Object.prototype.toString().call()

21. 懒加载怎么实现的

图片懒加载

路由懒加载

22. 实现动画效果都有什么方式

    - javascript 直接实现；
    - SVG（可伸缩矢量图形）；
    - CSS3 transition；（补间动画）
    - CSS3 animation；（帧动画）
    - Canvas 动画；
    - requestAnimationFrame；

23. CSS3 的特性

24. 垂直居中

- 绝对定位和负外边距
- 绝对定位和 transform
- 绝对定位和 margin: auto
- 使用 padding 实现子元素的垂直居中
- 设置第三方基准
- 使用 flex 布局
- 使用 line-height 对单行文本进行垂直居中
- 使用 display: table; 和 vertical-align: middle; 对容器里的文字进行垂直居中
- 使用 CSS Grid

25. flex：1 代表什么 应用场景？
    建议使用单值缩写，而不是完整的 3 个属性值，因为单值属性所对应的 flex 计算值根据开发者日常最常用的使用进行了优化。

    是以下的属性的缩写: flex-grow，flex-shrink 和 flex-basis

    - flex-grow :定义项目的放大比例，默认为 0
    - flex-shrink :定义项目的缩小比例,默认为 1
    - flex-basis :定义项目在分配多余的空间之前，项目占据的主轴空间 默认为 auto（item 本来大小）

    flex:1 等同于 flex:1 1 0%，flex:1 2 等同于 flex:1 2 0%，即 flex-basis 使用的不是默认值 auto，而是使用的 0%；

    flex:100px 等同于 flex:1 1 100px，即 flex-grow 使用的不是默认值 0，而是使用的 1；

26. css 实现三角形 圆形

border
border radius

27. 不给定宽高 实现正方形

28. 伪类和伪元素分别是什么 有什么区别

- 伪类其核心就是用来选择那些不能够被普通选择器选择的文档之外的元素，比如:hover。
- 伪元素其核心就是需要创建通常不存在于文档中的元素，比如::before。
- 区别伪元素其实相当于伪造了一个元素，例如 before,first-letter 达到的效果就是伪造了一个元素，然后添加了其相应的效果而已；而伪类没有伪造元素，例如 first-child 只是给子元素添加样式而已。

结论

- 伪类和伪元素都是用来表示文档树以外的"元素"。
- 伪类和伪元素分别用单冒号:和双冒号::来表示。
- 伪类和伪元素的区别，最关键的点在于如果没有伪元素(或伪类)，是否需要添加元素才能达到目的，如果是则是伪元素，反之则是伪类。

29. css 优先级

通配\*(0) < element(1) < class(10) < id(100)
数字仅仅用于理解, 如果有 10 个 class 和一个 id, 直接使用 id 的样式

30. vw vh

视窗大小

31. 怎么显示小于 12px 的字体

使用缩放 transform:scale()，使用较为广泛

优点：单行、多行文本都可使用
缺点：只是视觉效果变小，并不会改变盒子的实际占位，在对齐其他盒子时不太友好

Zoom 非标属性，有兼容问题，缩放会改变了元素占据的空间大小，触发重排

-webkit-transform:scale() 大部分现代浏览器支持，并且对英文、数字、中文也能够生效，缩放不会改变了元素占据的空间大小，页面布局不会发生变化

-webkit-text-size-adjust 对谷歌浏览器有版本要求，在 27 之后，就取消了该属性的支持，并且只对英文、数字生效

32. 行内元素有哪些 块元素有哪些
    常见的块级元素有：div、p、h1~h6、ul、ol、li、dl、dt、dd、table、form 等。
    常见的行内元素有：span、a、img、input、label、select、textarea、button、strong、em、i、b 等

33. 介绍一下 BFC
    BFC(Block formatting context)，名为块级格式化上下文，它的作用是形成独立的渲染区域，内部元素的渲染不会影响外界

    形成 BFC 常见的条件(满足其中一条就可以触发 BFC)

    - 根元素\<html\>
    - 浮动元素：float 不是 none
    - 定位元素：position 是 absolute 或 fixed
    - overflow 不是 visible
    - display 为 inline-block 或 flex

34. 权限这一块怎么做的

35. git flow 工作流 开发流程

36. 将当前代码暂存用 git 哪条命令

git stash

37. git 怎么回退代码 reset 和 revert 有什么区别
    git reset 是把 HEAD 向后移动了一下，而 git revert 是 HEAD 继续前进，只是新的 commit 的内容和要 revert 的内容正好相反，能够抵消要被 revert 的内容;

38. 项目中有做过 seo 吗 怎么做的

如果对于已有的单页面进行优化可采取如下两种解决方案：

- 预渲染的方式，使用 prerender-spa-plugin 插件
- 更改成 SSR

39. 介绍一下项目中让你印象深刻的地方
